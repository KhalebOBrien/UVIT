
# УВИТ - Програмски језик ЈаваСкрипт

[Владимир Филиповић](https://vladofilipovic.github.io/index-cy.html){:target="_blank"}

## Асинхроно програмирање

### Типични модели извршавања програма

Према начину извршавања програма, типично се говори о следећим  моделима извршавања:

- синхрони (програм се извршава сукцесивно)

- вишенитни (више процеса се извршава упоредо)

- асинхрони (програм се извшава на прескок, како шта постаје доступно)

#### Синхрони модел програмирања

Синхрони модел је најстарији и најједноставнији модел про­грамирања. Задаци се извршавају сукцесивно, један по један, и тек када се изврши претходни, почиње следећи.

У синхроном моделу, наредба која следи ће бити извршена тек након што се изврши наредба која њој претходи. Ако се догоди да је наредба која претходи скупа и да дуго траје, наредба ће бити бло­кирана, мораће да чека. Ово је озбиљан проблем када се развијају системи високих перформанси.

Постоји још један проблем код синхроног модела, који се манифестује код корисничког интерфејса. Док програм извршава задатак који може да потраје неко време, нема могућности да се бло­кирају корисници, који могу да уносе нешто у поље за унос док се извршава скупи задатак. Са друге стране, не би било добро да се блокиа унос корисника током извршавања скупе операције - захтевни задаци треба да се извршавају у позадини.

#### Вишенитни модел програмирања

Једно од решења овог проблема је да се сваки задатак подели на програмске нити контроле. Ово се зове вишенитни модел (multithreading). У вишенитном моделу сваки задатак се извршава у нитима контроле. Нитима, обично, управља оперативни систем и оне могу да се извршавају упоредо на другим процесорима. Захваљујући модер­ним процесорима, вишенитни модел може да има изузетно добре перформансе. Неко­лико језика подржава овај модел (C#, C++, Java, Rust…).

Вишенитни модел може бити комплексан за имплементирање. Наиме, нити треба међусобно да сарађују, што може врло брзо да постане „незгодно“. Но, постоје варијације вишенитног модела у којима је стање непроменљиво и тада се модел поједностављује, јер свака нит је одговорна за непроменљиво стање и нема потребе да се управља стањима између нити.

#### Асинхрони модел програмирања

Модел асинхроног програмирања има једну нит кон­троле, унутар које се задаци преплићу. Када се извршава један задатак, може се бити сигуран само да тај задатак извршен. У асинхроном моделу није потребан сложен механизам за комуникацију између нити, па је зато предвидљивији.

У којим ситацијама је асинхрони модел бољи од синхроног? Када год програм чека нешто - учитавање података са диска, упит према бази података или мрежне захтеве. Ово су све блокирајуће операције. У случајевима када програм има много улаза/излаза из извора као што су учитавање диска или мрежни позиви, кашњење се не може предвидети. У синхроном програму непредвидљивост је „рецепт“ за лошу перформансу. Када се асинхрони програм суочи са блокирајућим задатком, извршава се наредни задатак, без чекања да се блокирајућа операција заврши.

### Асинхроно програмирање у ЈаваСкрипту

#### ЈаваСкрипт окружење и асинхроно програмирање

ЈаваСкрипт окружење за извршавање се састоји од следећих компоненти:

- ЈаваСкрипт машина (JS Engine)
  - Хип 
  - Стек
- Спољашњи API-ји
- Ред повратних позива (Ред задатака)
- Петља за догађаје

![ЈаваСкрипт окружење за извршавање](assets/images/event-loop-400-4.jpg)

Асинхроно програмирање се рализује тако што се наредбе извршавају једна за другом - програмски код се поставља на Стек и извршава се онај код који је на вргу стека. 

Међутим, ако су неке наредбе/позиви функција такви да их не треба одмах извршити, њихов програмски код се ставља у одвојени ред за чекање, па се (по испуњењу услова) премести у Ред задатака.

У међувремену се настави са извршавањем наредби које следе - он се гурају на Стек и тамо извршавају (ако су такве да их треба одмах иѕвршити).

Када стек постане празан, Петља за догађаје узима елементе из Реда задатака, пребавује је их на Стек и онда тај програмски код бива извршен.

Овим је постигнуто да се не чека приликом извршавања "скупих" наредби, већ се наставља са извршавањем.

Наравно, јасно је да треба обезбедити и неке механизме координације у оваквом раду.

Постоји више програмских приступа у ЈаваСкрипту којима се реализује асинхроно програмирање.

Историјски нјстарији је рад помоћу функција повратног позива (callback function).

#### Повратни позиви

**Пример.** Илуструје рад са повратним позивом:

```js
let povratniPoziv = () => {
  console.log(`Ziv sam!`)
}

console.log(`Pokrenuto...`)
setTimeout(povratniPoziv, 2000)
console.log(`Zavrsava...`)
```

ЈаваСкрипт окружење извшава скрипту нарабу по наредбу:

1. Прво стави на стек прву `console.log` методу и затим је изврши.

2. Након тога окружење извршава наредбу где се позива `setTimeout`, па ову методу ставља на врх стекаа и извршава је.

3. По извршења `setTimeout` методе она се склања са стека, а њена функција повратног позива (callback) на коју реферише променљива `povratniPoziv` се пребацује у ред повратних позива на чекању и укључује часовник који броји милисекунде.

4. Потом окружење наставља са обрадом наредне наредбе кода где наилази на други позив `console.log` методе,коју ставља на стек и извршава је.

5. Док се извршава остали део програма, а по истеку времена задатог позиву `setTimeout` (овде је то `2000`) функција повратног позива се се пребацује у ред задатака и тамо чека да се стek изпразни да би могла да се изрши.

6. Петља за догађаје потом, када стек постане празан, а овај задатак "дође на ред" пребацује задатак (тј. функцију повратног позива) из реда задака на стек.

7. Када се функција повратнг позива нађе на стеку, она се извршава и након тога склања са стека.

Према томе, излаз који ће се показати на конзоли је:

```bash
Pokrenuto...
Zavrsava...
Ziv sam!
```

&#9608;

##### Коришћење повратних позива код низова

#### Обећања

#### Наредбе async и await

#### Наредбa yield

### Часовници

### Догађаји

### Литература

1. Haverbeke M.: [Eloquent JavaScript](https://eloquentjavascript.net/){:target="_blank"}

1. [JavaScript](https://developer.mozilla.org/en-US/docs/Web/JavaScript){:target="_blank"} - Mozzila Developer Network (MDN)

1. Живановић, Д.: [Веб програмирање - ЈаваСкрипт догађаји](https://www.webprogramiranje.org/dogadjaji-u-javascript-u/){:target="_blank"}

1. Copes F.: [Complete JavaScript Handbook](https://medium.freecodecamp.org/the-complete-javascript-handbook-f26b2c71719c){:target="_blank"}
