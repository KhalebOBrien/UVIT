
# УВИТ - Програмски језик ЈаваСкрипт

[Владимир Филиповић](https://vladofilipovic.github.io/index-cy.html){:target="_blank"}

## Функције и затворења

Слично као кŏд других виших програмских језика, функције служе за бољу организацију програмског кŏда - секевнце наредби које представљају логичку целину се организују у функције.

У језику ЈаваСкрипт, поред горе побројаног, функције карактерише чињеница да представљају тзв. “грађане првог реда” (first class citizen).  Ако програмски ентитети јесте "грађанин првог реда", то онда значи да такав ентитет подржава све операције доступне другим типовима и може да се понаша потпуно исто као било која друга врста ентитета која је грађанин првог реда. Конкретно код ЈаваСкрипта, пошто су функције грађани првог реда, код њих не постоји рестрикција како се креирају или користе и они имају особине свих примитива као и све особине објекта.

Дакле, функција има све особине других примитива, па се може проследити као аргумент, може се вратити као резултат неке друге функције или се можем доделити некој промењивој. Надаље, поред набројаних особина, функције имају и све особине објеката. На крају, поред свих особина објекта и примитива, функције садрже и додату семантику за позивање.

Као што смо видели у претходним поглављима, јаваСкрипт се испоручује са скупом "уграђених" тј. предефинисаних функција, које су одмах на располагању програмеру. Наравно, језик допушта ЈаваСкрипт програмеру и да креира сопствене функције.

Постоје два начина за дефинисање функција: помоћу декларације и помоћу функцијског израза.

### Декларација и позив функције

Један вид рада са функцијама у језику ЈаваСкрипт је да се функција креира декларисањем. Синтакса декларисања и позива тако направљене функције веома подсећа на декларисање и прозив функције у другим "мејнстрим" програмским језицима, као што су Јава и Це.

Позив фунције се реализује слично као у јеѕицима Јава и Це, навођењем наѕиве функције иза кога, у заградама, следи листа аргумената међусобно раздвојених ззарезом. Иѕвршење позива доводи до тога да извршавање наставља од прве наредбе функције, при чему су параметри функције замењени прослеђеним аргументима. По ѕавршетку извршавања позване функције, извршавање програма се наставља од наредебе које следи иза наредбе позива.

**Пример.** Декларација и позиви функције за квадрирање броја:

```js
function kvadrat(x) {
    return x * x;
};

console.log(`Kвадрат броја 12 је ${kvadrat(12)}`);
let y = kvadrat(13);
console.log(`Kвадрат броја 13 је ${y}`);
y = 14;
console.log(`Kвадрат броја ${y} је ${kvadrat(y)}`);
```

### Функцијски израз и позив фуункције

Један вид рада са функцијама у језику ЈаваСкрипт је да се функција одреди функцијским изразом. У том виду рада са функцијом, функција заиста постаје "грађанин првог реда". Стога ћемо, у примерима који следе, обично користити функцијске изразе.

И код фунцијских израза се позив фунције реализује навођењем наѕиве функције иза кога, у заградама, следи листа аргумената међусобно раздвојених ззарезом.

**Пример.** Фунцијски израз за квадрирање броја и позиви тако направљене функције:

```js
let kvadrat = function(x) {
  return x * x;
};

console.log(kvadrat(12));
console.log(`Kвадрат броја 12 је ${kvadrat(12)}`);
let y = kvadrat(13);
console.log(`Kвадрат броја 13 је ${y}`);
y = 14;
console.log(`Kвадрат броја ${y} је ${kvadrat(y)}`);
```

У претходном примеру, дакле, `kvadrat` је променљива која реферише на функцију - грубо речено, садржи адресу "нечега" што за прослеђени аргумент враће произвид тог аргумента са самим собом.

Приликом поѕива функције, врши се замена тј. супституција параметара функције аргументима позива. У језику ЈаваСкрипт, врши се тзв супституција по вредности, израчунавају се вредности аргумената приликом позива и израчунате вредности редом замењују параметре функције.

### Параметри и аргументи функција

За разлику од највећег броја "мејнстрим" програмских језицика (као што су Јава и Це), где приликом позива параметри функције и аргументи позива морају бити сагласни по броју и типу, то код ЈаваСкрипта уопште није случај. Наравно, јасно је да се због слабе типизираности језика ЈаваСкрипт не може проверавати сагласност типова параметара и аргумената, али такође није обавезно ни да се поклопи број аргумената у позиву функције са бројем параметара функције.

Ако је број аргумената позива већи од броја параметара функције, тада се изврши супституција онолико парамеатара колико их има у дефиницији функције, преостали тј. вишак једноставно буде игнорисан.

**Пример.** Позив функције, где је број аргумената у позиву већи од броја параметара функције:

```js
let buka = function() {
    console.log(" Tras !");
};

buka();
buka();
// vidimo da broj argumenata moze biti veci
// od broja parametara funkcije
buka("Petar");
```

У случају позива функције када је број аргумената у позиву мањи од броја параметара функције, параметри функције ће добити вредност `undefined`. У претходним поглављима је описано како се евалуира израз који има `undefined` операнде.  

**Пример.** Позив функције, где се број аргумената у позиву мањи од броја параметара функције:

```js
const stepen = function(osnova, izlozilac) {
    let ret = 1;
    for (let i = 0; i < izlozilac; i++)
        ret *= osnova;
    return ret;
};

console.log(stepen(3, 4));
console.log(stepen(4, 3));
console.log(stepen(4));
console.log(stepen());
```

Ако је потребно, може се одлучити да се у самом телу функције проверава да ли је извршена супституција параметра са аргументом или не.

**Пример.** Провера у телу функције да ли је правилно извршена супституција параметара аргументима:

```js
let stepen = function (osnova, izlozilac) {
    if (osnova == undefined)
        osnova = 10;
    if (izlozilac == undefined)
        izlozilac = 2;
    let ret = 1;
    for (let i = 0; i < izlozilac; i++)
        ret *= osnova;
    return ret;
};

console.log(stepen(3, 4));
console.log(stepen(4, 3));
console.log(stepen(4));
console.log(stepen());
```

#### Опциони параметри функција

Елегантнији начни за проверу да се да ли је извршена супституција параметра са аргументом је коришћење такозваних опционих параметара функције. Параметар постаје опциони ако се у дефиницији функције, приликом навођењна параметра специфицира његова подразумевана вредност. У том случају, ако приликом позива функције за опциони параметар не буде дат аргумент, параметар ће добити подразумевану вредност која му је дата у дефиницији функције.

**Пример.** Опциони параметри функције:

```js
const stepen = function (osnova = 10, izlozilac = 2) {
    let ret = 1;
    for (let i = 0; i < izlozilac; i++)
        ret *= osnova;
    return ret;
};

console.log(stepen(3, 4));
console.log(stepen(4, 3));
console.log(stepen(4));
console.log(stepen());
```

На крају, треба истаћи да приликом сваког позива функције, постоји могућност да се приступи аргументима позива (било да их је више, мање или тачно колико треба) коришћењем [`arguments`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments){:target="_blank"}, о чему ће бити речи у каснијим поглављима.

### Опсези важења за променљиве и функције

Као што је истакнуто у претходном [поглављу](JavaScript-Programski-Jezik-Struktura-Programa#опсези-важења-променљивих-у-циклусима){:target="_blank"}, ако је променљива декларисана коришћењем `let` или `const` опсег важења променљиве је блоковски. Ако је променљива декларисана коришћењем `var` опсег важења променљиве је функцијски, што значи да ће се моћи приступити променљивој у опсегу функције у којој је та промељива дефинисана.

Наравно, у телу функције се може приступити свим параметриам функције и свим променљивима које су глобалне за ду функцију, тј. дефинисане у опсезима  који садрже дефиницију дате функције.

**Пример.** Илуструје како се модификује променљива која је глобална за дату функцију:

```js
let test = "globalna vrednost";
function testirajOpsegDefinisanosti() {
  test = "lokalna vrednost";
  console.log(test);
}
console.log(test);              // >>> globalna vrednost
testirajOpsegDefinisanosti();   // >>> lokalna vrednost
console.log(test);              // >>> lokalna vrednost
```

#### Стек позива за функције

Функција у свом телу може садржати један или више позива других функција, или чак може да позива саму себе. Позив функције и повратак из функције се, исто као и у другим популарним језицима данашњице, постиже коришењем структуре података стек. ЈаваСкрипт извршно окружење  приликом сваког позива функције на стек смешта тзв. [стек-оквир](https://v8docs.nodesource.com/node-0.8/d4/da0/v8_8h_source.html#l00806){:target="_blank"} (stack frame) за функцију, који садржи адресу повратка, тј. описује од које ће се локације у скрипту наставити извршавање. Приликом завршетка рада функције, са стека се скида претходно постављени стек-оквир и ЈаваСкрипт извршно окружење наставља извршавање од локације која је чувана у том стек-оквиру.

Дакле, можемо сматрати да у ЈаваСкрипту позиви функција током извршења прогеамског кода образују стек, који се назива стек позива за функције.

**Пример.** Илустрација како неправилним коришћењем може бити препуњен стека позива за функције - програм треба да одреди да ли је старија кокошка или јаје :) :

```js
function kokoska() {
    return jaje();
};

function jaje() {
    return kokoska();
}

console.log("Starija je ", kokoska());
```

**Пример.** Резукзивна функција за израчунавање степена основе позитивним целобројним изложиоцем:

```js
function stepen(osnova, izlozilac) {
    if (izlozilac == 0)
        return 1;
    return osnova * stepen(osnova, izlozilac - 1);
}

console.log(stepen(3,4))
```

**Пример.** Узајамна рекурзија којом се проерава да је дати број паран/непаран:

```js
function paran(broj) {
    if (broj == 0)
        return true;
    if (broj == 1)
        return false;
    return paran(broj - 2);
}

function neparan(broj) {
    return !paran(broj);
}

console.log(paran(50));
console.log(neparan(50));
console.log(paran(75));
console.log(neparan(75));
```

**Пример.** Нетривијално коришћење рекурзије - функција за проверу да ли се дати број може направити од броја `1`, узастопним понављањем множења са `3` и/или додавања `5` у било ком редоследу:

```js
function pronadjiResenje(cilj) {
    function pronadji(start, istorija) {
        if (start == cilj)
            return istorija;
        else if (start > cilj)
            return null;
        else
            return pronadji(start + 5, "(" + istorija + " + 5) ") ||
                pronadji(start * 3, "(" + istorija + " * 3) ");
    }
    return pronadji(1, "1");
}

for(let i=1; i<71; i++)
    console.log(i + " = "+ pronadjiResenje(i));
```

### Затворења за функције

**Пример.** Функција којим се омотава дата вредност:

```js
function omotajVrednost(n) {
    let lokalnaPromenljiva = n;
    return function() {
        return lokalnaPromenljiva;
    };
}

let omotacZa1 = omotajVrednost(1);
let omotacZa2 = omotajVrednost(2);

console.log(omotacZa1());
console.log(omotacZa2());

```

### Ламбда изрази и функције

**Пример.** Дефинисање функције функцијским изразом на "класичан" начин и помоћу ламбда израза:

```js
let square = function(x){return x*x}
console.log(square(12))

let square2 = (x)=> {return x*x}
console.log(square2(12))

let square3 = (x)=> x*x
console.log(square3(12))
```

**Пример.** Декларација и позив функције за степеновање дефинисане помоћу ламбда-израза:

```js
let stepen = (osnova = 5, izlozilac = 2) => {
    let ret = 1;
    for (let i = 0; i < izlozilac; i++)
        ret *= osnova;
    return ret;
};

console.log(stepen(3, 4));
console.log(stepen(4));
console.log(stepen());
```

**Пример.** Генерисање функција за квадрирање, дизање на куб и дизање на десети степен, коришћењем затворења, помоћу ламбда-израза:

```js
const stepenovanje = (izlozilac = 2) => {
    return (osnova) => {
        let ret = 1;
        for (let i = 0; i < izlozilac; i++)
            ret *= osnova;
        return ret;
    };
}

const kvadriranje = stepenovanje(2);
console.log(kvadriranje(4.5));
const naKub = stepenovanje(3);
console.log(naKub(4));
const naDeseti = stepenovanje(10);
console.log(naDeseti(2));
```

### Дизање променљивих и функција

Принцио дизања променљивих и функција  (hoisting) се односи на ситуацију да декларисање променљиве и функције било где у кŏду има исти ефекат као да је та променљива декларисана на почетку програмског кŏда.

#### Дизање променљивих

За променљиве са блоковским опсегом дефинисаности, тј. променљивима дефинсаним помоћу `let` и `const`, не важи концепт дизања променљивих.

**Пример.** Илуструје немогућност дизања променљиве са блоковским опсегом дефинисаности.

```js
console.log(x);
let x = 5;
```

Код променљивих које су декларисане помоћу резервисане речи `var`, ситуација је другачија. Ту се декларација промењиве дешава пре извршавања било ког дела кŏда,па декларисање променљиве било где у кŏду има исти ефекат као да је та променљива декларисана на почетку кода. Према томе, у случају када се  реферише на неку такву променњиву у делу кŏда који претходи њеној декларацији, тада неће бити избачена грешка али вредност те промењиве неће бити дефинисана.

**Пример.** Илуструје дизање променљиве декларисане помоћу `var`.

```js
console.log(x);
var x = 5;
```

 Иако је променљива `x` дефинисана тек послe позива функције за њен приказ, декларација променљиве `x` је "дигнута", тако да у тренутку позива функције променљива постоји. Међутим, додела вредности променљиве се реализује на месту где је написана у програмском коду, после позива функције за приказ, тако да овде, приликом позива функције за приказ дигнута променљива још увек нема вредност.

Уколико се уопште не декларише променљива у коду, промењива ће бити декларисана "у лету" у глобалном опсегу дефинисаности и биће доступна из целог програмског кŏда. Међутим, ова радња се изводи тек у време извршавања кŏда, што наступа након тренутка када се извршава “дизање” промењивих на врх кода. Стога, будући да је прошао тренутак када се врши дизање, таква промењива неће бити дигнута на почетак кода. Стога, уколико се реферише на такву промењива пре њенњ појаве у коду,биће избачена грешка!

**Пример.** Илуструје како глобалне променљиве неће бити дигнуте.

```js
console.log(x);
x = 5;
```

#### Дизање функција

Декларација функције се такође одвија пре извршења кода, стога се, исто као код промењивих, може сматрати да су функције писане на почетку кода. Поступак дизања декларисаних функција (цела функција са телом) на почетак програмског кода назива се дизање функције.

:small_red_triangle_down:**Пример.** Дизање функције:

```js
console.log("buducnost vraće:", buducnost());

function buducnost() {
    return "Još uvek ne postoje leteći automobili";
};
```

Као што видимо у претходном примеру, функцију можемо да декларишемо на крају кода и да је позивамо са почетка, а да не дође до грешке. :small_red_triangle:

Треба нагласити да се дизање функција одвија пре дизања промењивих.

:small_red_triangle_down:**Пример.** Ефекат извршења следеће скрипте:

```js
var test = function (){
  console.log("prikaz iz funkcijskog izraza");
}

function test(){
  console.log("prikaz iz deklarisane funkcije");
}

test();  
```

се боље види ако експлицитно се прикаже како изгледа ЈаваСКрипт код када се изврши дизање променљивих и функција:

```js
function test(){
  console.log("iz deklarisane funkcije");
}                                        // prvo se diže cela funkcija
var test;                                // zatim se diže deklaracija promenjive
var test = function (){
  console.log("iz function expression");
}                                        // ostalo na istom mestu u kodu
test();                                  // ostalo na istom mestu u kodu
```

:small_red_triangle:
